---
title: 'Pure Rust ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªfaerå…¥é–€â‘¡ æ¼”ç®—ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹'
description: 'faerã«ãŠã‘ã‚‹åŸºæœ¬çš„ãªè¡Œåˆ—æ¼”ç®—ã«ã¤ã„ã¦ã€æ¼”ç®—å­ã‚’ç”¨ã„ãŸè¨˜è¿°æ–¹æ³•ã‹ã‚‰ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ãªzip!ãƒã‚¯ãƒ­ã‚„matmulã‚’ç”¨ã„ãŸå®Ÿè£…æ–¹æ³•ã¾ã§è§£èª¬ã—ã¾ã™ã€‚'
pubDate: 2025-12-24
updatedDate: 2025-12-24
heroImage: ''
tags: ['programming', 'numerical analysis', 'mathematics']
---

<div style="background: linear-gradient(135deg, #8b0000 0%, #c41e3a 100%); padding: 0.5rem; border-radius: 8px; margin: 2rem 0;">
  <p style="color: white; margin: 0; text-align: left; font-size: 1.1rem;">
    ğŸ„ <a href="https://qiita.com/advent-calendar/2025/rust" style="color: white; text-decoration: underline; font-weight: bold;">Rust Advent Calendar 2025</a> 24æ—¥ç›® ğŸ„
  </p>
</div>

å‰å›ã®è¨˜äº‹ã€Œ[Pure Rust ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªfaerå…¥é–€â‘ ](https://thermocraft.space/ja/articles/faer-basics/)ã€ã§ã€faerã®åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿å‹ã§ã‚ã‚‹Matï¼ˆæ‰€æœ‰ï¼‰ã¨MatRefï¼ˆãƒ“ãƒ¥ãƒ¼ï¼‰ã®å†…éƒ¨æ§‹é€ ã«ã¤ã„ã¦è§£èª¬ã—ãŸã€‚
ã“ã‚Œã‚‰ã¯è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã‚’åŠ¹ç‡çš„ã‹ã¤å®‰å…¨ã«ç®¡ç†ã™ã‚‹ãŸã‚ã®ä»•çµ„ã¿ã ã£ãŸãŒã€ä»Šå›ã¯ãã‚Œã‚‰ã‚’ä½¿ã£ã¦è¡Œã†åŸºç¤çš„ãªæ¼”ç®—ã«ç„¦ç‚¹ã‚’å½“ã¦ã‚‹ã€‚
ã¨ãã«faerãŒæä¾›ã™ã‚‹è¡Œåˆ—æ¼”ç®—APIã‚’ã€ã€Œæ›¸ãã‚„ã™ã•ã€ã¨ã€Œæ€§èƒ½ã€ã®è¦³ç‚¹ã‹ã‚‰æ¯”è¼ƒã—ã€ç”¨é€”ã«å¿œã˜ãŸä½¿ã„åˆ†ã‘ã‚’ç´¹ä»‹ã™ã‚‹ã€‚

ä»Šå›ã®è¨˜äº‹ã§ã‚‚ã€2025å¹´12æœˆæ™‚ç‚¹ã§ã®æœ€æ–°ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚ã‚‹0.23.2ã‚’ä½¿ç”¨ã™ã‚‹ã€‚

```toml
[dependencies]
faer = "0.23.2"
```

## æ¼”ç®—å­ã«ã‚ˆã‚‹è¡Œåˆ—æ¼”ç®—

faerã§ã¯ã€æ¨™æº–çš„ãªç®—è¡“æ¼”ç®—å­ï¼ˆ`+`, `-`, `*`ï¼‰ãŒå®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€ç›´æ„Ÿçš„ã«è¡Œåˆ—è¨ˆç®—ã‚’æ›¸ãã“ã¨ãŒã§ãã‚‹ã€‚
ãŸã ã—`*`ã¯è¦ç´ ã”ã¨ã®ç©ã§ã¯ãªãã€è¡Œåˆ—ç©ã‚’è¡¨ã™ã“ã¨ã«æ³¨æ„ã—ã‚ˆã†ã€‚

```rust
use faer::{Mat, MatRef, mat};

fn main() {
    let a = mat![[1.0, 2.0], [3.0, 4.0]];
    let b = mat![[5.0, 6.0], [7.0, 8.0]];

    // 1. è¡Œåˆ—ã®å’Œ
    let c: Mat<f64> = &a + &b;
    println!("{:?}", c);
    // [
    // [6.0, 8.0],
    // [10.0, 12.0],
    // ]

    // 2. è¡Œåˆ—ã®å·®
    let d: Mat<f64> = &a - &b;
    println!("{:?}", d);
    // [
    // [-4.0, -4.0],
    // [-4.0, -4.0],
    // ]

    // 3. è¡Œåˆ—ã®ç©
    let e: Mat<f64> = &a * &b;
    println!("{:?}", e);
    // [
    // [19.0, 22.0],
    // [43.0, 50.0],
    // ]
}
```

## ã‚ˆã‚ŠåŠ¹ç‡çš„ãªè¡Œåˆ—æ¼”ç®—

ã“ã‚Œã‚‰ã®æ›¸ãæ–¹ã¯ç›´æ„Ÿçš„ã§ä¾¿åˆ©ã ãŒã€è¡Œåˆ—æ¼”ç®—ãŒè¡Œã‚ã‚Œã‚‹ãŸã³ã«çµæœãŒæ–°ã—ã„è¡Œåˆ—ã¨ã—ã¦ç¢ºä¿ã•ã‚Œã‚‹ãŸã‚ã€è¤‡é›‘ãªè¡Œåˆ—ã®æ¼”ç®—ã‚’è¡Œã†å ´åˆã«ã¯éåŠ¹ç‡ã«ãªã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€æ¼”ç®—å­ã‚’ç”¨ã„ãŸè¨˜è¿°æ–¹æ³•ã¨ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ãªzip!ãƒã‚¯ãƒ­ã‚„matmulã‚’ç”¨ã„ãŸå®Ÿè£…æ–¹æ³•ã‚’æ¯”è¼ƒã™ã‚‹ã€‚

### Case 1: 3ã¤ã®è¡Œåˆ—ã®è¶³ã—ç®— (D = A + B + C)

è¶³ã—ç®—ã€å¼•ãç®—ã€ã‚¹ã‚«ãƒ©ãƒ¼å€ãªã©ã®ã€è¦ç´ ã”ã¨ã®æ¼”ç®—ã«ã¤ã„ã¦ã¯ã€faerã¯`zip`é–¢æ•°ã‚’æä¾›ã—ã¦ã„ã‚‹ã€‚
ã“ã‚Œã‚’ç”¨ã„ã‚‹ã¨ã€ä¸­é–“çµæœã‚’ä¿æŒã›ãšã«è¤‡æ•°ã®è¡Œåˆ—ã‚’ä¸€åº¦ã«æ¼”ç®—ã§ãã‚‹ã€‚

ã“ã“ã§ã¯ã€æœ€ã‚‚åŸºæœ¬çš„ãªä¾‹ã¨ã—ã¦ã€3ã¤ã®è¡Œåˆ—ã®å’Œ`D = A + B + C`ã‚’ã€æ¼”ç®—å­ã‚’ç”¨ã„ãŸæ–¹æ³•ã¨ã€`zip!`ãƒã‚¯ãƒ­ã‚’ç”¨ã„ãŸæ–¹æ³•ã§æ¯”è¼ƒã—ã¦ã¿ã‚ˆã†ã€‚

```rust
use faer::{zip, unzip, Mat};
use std::time::Instant;

fn main() {
    // 1024x1024 ã® f64 è¡Œåˆ—ã¯ç´„8MB
    let n: usize = 4096;
    let a: Mat<f64> = Mat::<f64>::from_fn(n, n, |i, j| (i + j) as f64);
    let b: Mat<f64> = Mat::<f64>::from_fn(n, n, |i, j| (i as isize - j as isize) as f64);
    let c: Mat<f64> = Mat::<f64>::full(n, n, 1.0);

    // ==========================================
    // Case 1: 3ã¤ã®è¡Œåˆ—ã®è¶³ã—ç®— (D = A + B + C)
    // ==========================================
    println!("--- Case 1: D = A + B + C ---");

    // 1. operators
    let start = Instant::now();
    let d_op = &a + &b + &c;
    println!("Operators: {:.2?}", start.elapsed());

    // 2. zip!
    let start = Instant::now();
    let mut d_zip = Mat::zeros(n, n);
    zip!(&mut d_zip, &a, &b, &c).for_each(|unzip!(d, a, b, c)| {
        *d = *a + *b + *c;
    });
    println!("zip!: {:.2?}", start.elapsed());

    // --- Case 1: D = A + B + C ---
    // 1. operators : 3.01ms
    // 2. zip!      : 1.94ms
}
```

`&a + &b + &c`ã®è¨ˆç®—ã§ã¯ä¸­é–“çµæœãŒç”Ÿæˆã•ã‚Œã‚‹ã®ã«å¯¾ã—ã€`zip!`ã‚’ç”¨ã„ãŸå ´åˆã¯1å›ã®çµæœè¡Œåˆ—ã®ç¢ºä¿ã®ã¿ã§æ¸ˆã‚€ãŸã‚ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã¨å‡¦ç†æ™‚é–“ãŒå‰Šæ¸›ã•ã‚Œã¦ã„ã‚‹ã€‚
ã“ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§ã¯ã€`zip!`ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ç´„1.5å€ã®é«˜é€ŸåŒ–ãŒé”æˆã•ã‚ŒãŸã€‚

### Case 2: ç©å’Œæ¼”ç®— (E = A + B \* C)

è¡Œåˆ—ç©ã‚’å«ã‚€æ¼”ç®—ã®å ´åˆã€è¡Œåˆ—ç©ã®æ¼”ç®—ãƒ«ãƒ¼ãƒ«ä¸Šã€ãªã‚“ã‚‰ã‹ã®å½¢ã§ä¸­é–“çµæœã‚’ä¿æŒã™ã‚‹ã“ã¨ã¯é¿ã‘ã‚‰ã‚Œãªã„ã€‚
ã—ã‹ã—ã€ã“ã®å ´åˆã§ã‚‚æ›¸ãæ–¹ã«ã‚ˆã£ã¦ã€è¨ˆç®—é€Ÿåº¦ã«å¤§ããªå·®ãŒå‡ºã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚

```rust
use faer::linalg::matmul::matmul;
use faer::{zip, unzip, Mat};
use std::time::Instant;

fn main() {
    println!("--- Case 2: E = A + B * C ---");
    let n: usize = 4096;
    let a: Mat<f64> = Mat::<f64>::from_fn(n, n, |i, j| (i + j) as f64);
    let b: Mat<f64> = Mat::<f64>::from_fn(n, n, |i, j| (i as isize - j as isize) as f64);
    let c: Mat<f64> = Mat::<f64>::full(n, n, 1.0);

    // ==========================================
    // 1. Operators
    // ==========================================
    let start = Instant::now();
    // Process:
    // 1. tmp = B * C (Alloc + matmul Replace)
    // 2. res = A + tmp (Alloc + Zip Add)
    let e1 = &a + &b * &c;
    println!("operators                 : {:.2?}", start.elapsed());

    // ==========================================
    // 2. clone + Add
    // ==========================================
    let start = Instant::now();
    // Process:
    // 1. res = A.clone() (Alloc + Copy)
    // 2. res += B * C (matmul Add)
    let mut e2 = a.clone();
    matmul(
        e2.as_mut(),
        Accum::Add,
        &b,
        &c,
        1.0,
        get_global_parallelism()
    );
    println!("copy + matmul Add         : {:.2?}", start.elapsed());

    // ==========================================
    // 3. Replace + Zip
    // ==========================================
    let start = Instant::now();
    // Process:
    // 1. res (Alloc)
    // 2. res = B * C (matmul Replace)
    // 3. res += A (Zip Add)
    let mut e3 = Mat::<f64>::zeros(n, n);
    matmul(
        e3.as_mut(),
        Accum::Replace,
        &b,
        &c,
        1.0,
        get_global_parallelism()
    );
    zip!(&mut e3, &a).for_each(|unzip!(e, a)| *e += *a); // equivalent to e3 += &a;
    println!("matmul Replace + zip Add  : {:.2?}", start.elapsed());

    // --- Case 2: E = A + B * C ---
    // 1. operators                 : 13.62ms
    // 2. copy + matmul Add         : 9.50ms
    // 3. matmul Replace + zip Add  : 9.51ms

}
```

ã“ã®ä¾‹ã§ã¯ã€3ã¤ã®æ–¹æ³•ã§`E = A + B * C`ã‚’è¨ˆç®—ã—ã¦ã„ã‚‹ã€‚

1. æ¼”ç®—å­ã‚’ä½¿ã£ãŸæ–¹æ³•ã§ã¯ã€`B * C`ã®çµæœãŒä¸­é–“è¡Œåˆ—ã¨ã—ã¦ç¢ºä¿ã•ã‚Œã€ãã®å¾Œ`A`ã¨ã®å’ŒãŒè¨ˆç®—ã•ã‚Œã‚‹ãŸã‚ã€2å›ã®è¡Œåˆ—ç¢ºä¿ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã€‚
2. `A`ã®ã‚¯ãƒ­ãƒ¼ãƒ³ã‚’çµæœè¡Œåˆ—ã¨ã—ã¦ä½œæˆã—ã€ãã®ä¸Šã«`B * C`ã®çµæœã‚’åŠ ç®—ã—ã¦ã„ã‚‹ã€‚
3. æœ€åˆã«ã‚¼ãƒ­ã§åˆæœŸåŒ–ã—ãŸçµæœè¡Œåˆ—ã‚’ç¢ºä¿ã—ã€ãã“ã«`B * C`ã®çµæœã‚’ä¸Šæ›¸ãã—ã€ãã®å¾Œ`A`ã‚’åŠ ç®—ã—ã¦ã„ã‚‹ã€‚

å®Ÿè¡Œæ™‚é–“ã‚’æ¯”è¼ƒã™ã‚‹ã¨ã€2ç•ªç›®ã¨3ç•ªç›®ã®æ–¹æ³•ãŒã»ã¼åŒã˜é€Ÿåº¦ã§ã‚ã‚Šã€1ç•ªç›®ã®æ–¹æ³•ã‚ˆã‚Šã‚‚é«˜é€Ÿã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚
ã“ã®ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã§ã¯ã€ãƒ¡ãƒ¢ãƒªç¢ºä¿ã®ã‚³ã‚¹ãƒˆãŒå¤§ããã€ä¸­é–“è¡Œåˆ—ã®ç”Ÿæˆã‚’é¿ã‘ã‚‹ã“ã¨ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒå‘ä¸Šã—ã¦ã„ã‚‹ã¨è€ƒãˆã‚‰ã‚Œã‚‹ã€‚
ãŸã ã—ã€2ç•ªç›®ã¨3ç•ªç›®ã®æ–¹æ³•ã§å®Ÿè¡Œæ™‚é–“ãŒã»ã¼åŒã˜ã«ãªã‚‹ã®ã¯ã€`cargo run --release`ã§æœ€é©åŒ–ã•ã‚ŒãŸå ´åˆã®çµæœã§ã‚ã‚Šã€Debugãƒ“ãƒ«ãƒ‰ã§ã¯æŒ™å‹•ãŒç•°ãªã‚‹ã®ã§æ³¨æ„ãŒå¿…è¦ã§ã‚ã‚‹ã€‚

### Case 3: è¤‡æ•°å›ã®è¡Œåˆ—ç© (F = A \* B \* C \* D \* E)

è¤‡æ•°å›ã®è¡Œåˆ—ç©ã‚’è¡Œã†å ´åˆã€å„ç©ã”ã¨ã«ä¸­é–“çµæœãŒç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¢—åŠ ã—ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ä¸‹ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
ä¾‹ãˆã°`A * B * C * D * E`ã¨ã„ã†ã€5ã¤ã®è¡Œåˆ—ã®ç©ã«ã¤ã„ã¦è€ƒãˆã¦ã¿ã‚ˆã†ã€‚

```rust
use faer::linalg::matmul::matmul;
use faer::{mat, zip, unzip, Accum, Mat, Scale, get_global_parallelism};
use std::time::Instant;
use std::hint::black_box;

fn main() {
    println!("--- Chain: A * B * C * D * E ---");
    let n = 1024;
    let loop_count = 50;

    let a = Mat::<f64>::from_fn(n, n, |i, j| (i + j) as f64);
    let b = Mat::<f64>::from_fn(n, n, |i, j| (i as isize - j as isize) as f64);
    let c = Mat::<f64>::full(n, n, 1.0);
    let d = Mat::<f64>::from_fn(n, n, |i, j| (j as isize - i as isize) as f64);
    let e = Mat::<f64>::from_fn(n, n, |i, j| (i * j) as f64);

    // ==========================================
    // 1. operators
    // ==========================================
    let start = Instant::now();
    for _ in 0..loop_count {
        let res = &a * &b * &c * &d * &e;
        black_box(res);
    }
    println!("operators (4 allocs) : {:.2?}", start.elapsed() / loop_count);

    // ==========================================
    // 2. ping-pong buffering
    // ==========================================
    let par = get_global_parallelism();
    let start = Instant::now();

    for _ in 0..loop_count {
        let mut buf1 = Mat::<f64>::zeros(n, n);
        let mut buf2 = Mat::<f64>::zeros(n, n);

        matmul(buf1.as_mut(), Accum::Replace, &a, &b, 1.0, par);
        matmul(buf2.as_mut(), Accum::Replace, &buf1, &c, 1.0, par);
        matmul(buf1.as_mut(), Accum::Replace, &buf2, &d, 1.0, par);
        matmul(buf2.as_mut(), Accum::Replace, &buf1, &e, 1.0, par);
        black_box(buf2);
    }
    println!("ping-pong buffering (2 allocs): {:.2?}", start.elapsed() / loop_count);

    // --- Chain: A * B * C * D * E ---
    // 1. operators (4 allocs)  : 34.40ms
    // 2. ping-pong (2 allocs)  : 32.57ms
}
```

ã“ã®ä¾‹ã§ã¯ã€2ã¤ã®æ–¹æ³•ã§5ã¤ã®è¡Œåˆ—ã®ç©ã‚’è¨ˆç®—ã—ã¦ã„ã‚‹ã€‚

1. æ¼”ç®—å­ã‚’ä½¿ã£ãŸæ–¹æ³•ã§ã¯ã€å„ç©ã”ã¨ã«ä¸­é–“è¡Œåˆ—ãŒç”Ÿæˆã•ã‚Œã‚‹ãŸã‚ã€4å›ã®è¡Œåˆ—ç¢ºä¿ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã€‚
2. Ping-Pong Bufferingã¨å‘¼ã°ã‚Œã‚‹æ–¹æ³•ã§ã¯ã€2ã¤ã®ãƒãƒƒãƒ•ã‚¡é ˜åŸŸã‚’äº¤äº’ã«ä½¿ç”¨ã—ã¦ä¸­é–“çµæœã‚’ä¿å­˜ã™ã‚‹ã“ã¨ã§ã€è¡Œåˆ—ç¢ºä¿ã®å›æ•°ã‚’2å›ã«æŠ‘ãˆã¦ã„ã‚‹ã€‚

ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰å†…ã§50å›ãƒ«ãƒ¼ãƒ—ã‚’å›ã—ã¦å¹³å‡ã‚’ã¨ã£ã¦ã„ã‚‹ã®ã¯ã€ã‚ãã¾ã§è¨ˆæ¸¬ã®å®‰å®šåŒ–ã‚’å›³ã‚‹ãŸã‚ã§ã‚ã‚Šã€`A * B * C * D * E`ã®é€Ÿåº¦è¨ˆæ¸¬ã‚’è¡Œã†ã“ã¨ãŒç›®çš„ã§ã‚ã‚‹ã€‚
ãªã®ã§ã€Ping-Pong Bufferingã®å ´åˆã‚‚ã€ãƒ«ãƒ¼ãƒ—å†…ã§2å›ãƒãƒƒãƒ•ã‚¡ã‚’ç¢ºä¿ã—ã¦ã„ã‚‹ã€‚
å®Ÿè¡Œæ™‚é–“ã‚’æ¯”è¼ƒã™ã‚‹ã¨ã€Ping-Pong Bufferingã®æ–¹ãŒã‚ãšã‹ã«é«˜é€Ÿã§ã‚ã‚‹ã“ã¨ãŒã‚ã‹ã‚‹ã€‚
ãƒ¡ãƒ¢ãƒªç¢ºä¿ã®ã‚³ã‚¹ãƒˆã¯ã€è¡Œåˆ—ç©ã®ã‚³ã‚¹ãƒˆã¨æ¯”è¼ƒã—ã¦å°ã•ã„ãŸã‚ã€åŠ‡çš„ãªæ”¹å–„ã«ã¯ãªã‚‰ãªã„ãŒã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«ã‚·ãƒ“ã‚¢ãªè¨ˆç®—ã‚’è¡Œã†å ´åˆã«ã¯è©¦ã—ã¦ã¿ã‚‹ä¾¡å€¤ãŒã‚ã‚‹ã€‚

## ã¾ã¨ã‚

ä»Šå›ã¯Rustã®ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªfaerã®åŸºæœ¬çš„ãªè¡Œåˆ—æ¼”ç®—ã«ã¤ã„ã¦è§£èª¬ã—ãŸã€‚
è¡Œåˆ—ã®å’Œã€å·®ã€ç©ãªã©ã®æ¼”ç®—1å›ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯faerãŒå®Ÿè£…ã™ã‚‹æ¼”ç®—å­ã§ç°¡å˜ã«è¨˜è¿°ã§ãã€é«˜é€Ÿã«å®Ÿè£…ã§ãã‚‹ãŒã€è¤‡æ•°å›ã®æ¼”ç®—ã‚’çµ„ã¿åˆã‚ã›ã‚‹å ´åˆã«ã¯ã€ä¸­é–“çµæœã®ç”Ÿæˆã‚’é¿ã‘ã‚‹ãŸã‚ã«`zip!`ã‚„`matmul`é–¢æ•°ã‚’ç”¨ã„ãŸæ˜ç¤ºçš„ãªå®Ÿè£…ãŒå¿…è¦ã«ãªã‚‹å ´åˆãŒã‚ã‚‹ã€‚
æ¬¡å›ã¯ã€faerãŒæä¾›ã™ã‚‹ã‚ˆã‚Šé«˜åº¦ãªç·šå½¢ä»£æ•°æ©Ÿèƒ½ã«ã¤ã„ã¦è§£èª¬ã—ã¦ã„ããŸã„ã€‚
